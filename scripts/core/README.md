# Core Scripts

The `scripts/core` folder contains central components for managing project structure and configuration.

- `__init__.py`: Marks the folder as a Python package. This file is intentionally kept empty.
- `project_manager.py`: Defines the `ProjectManager` class, a cornerstone for organizing and accessing project resources.

## ProjectManager

The `ProjectManager` class is responsible for establishing and managing the workspace of a Retrieval Augmented Generation (RAG) project. It centralizes project configuration and directory structure, ensuring consistency across different parts of the application.

### Key Responsibilities:

1.  **Project Root Directory**:
    *   Initializes with a specific root directory for the project (e.g., `./my_rag_project/`). All other project paths are resolved relative to this root.

2.  **Configuration Loading**:
    *   Loads project-specific configurations from a `config.yml` file expected to be present in the root directory. This is handled using `scripts.utils.config_loader.ConfigLoader`.
    *   The loaded configuration is available via the `project.config` attribute (a dictionary).

3.  **Directory Structure Management**:
    *   Defines and ensures the existence of several key directories within the project. If these directories do not exist, `ProjectManager` creates them during initialization. The standard structure includes:
        *   `input_dir`: For storing input documents and processed chunk files. (Defaults to `<root_dir>/input`)
        *   `output_dir`: For storing general outputs from various processes. (Defaults to `<root_dir>/output`)
        *   `logs_dir`: For storing log files generated by different modules. (Defaults to `<root_dir>/output/logs`)
        *   `faiss_dir`: For storing FAISS index files used by the retrieval system. (Defaults to `<root_dir>/output/faiss`)
        *   `metadata_dir`: For storing metadata associated with embeddings or documents, typically in JSONL format. (Defaults to `<root_dir>/output/metadata`)

4.  **Path Accessors**:
    *   Provides convenient methods to get absolute paths to specific files or directories within the managed structure. This promotes consistency and reduces hardcoding of paths elsewhere in the codebase. Key accessor methods include:
        *   `get_input_dir() -> Path`: Returns the path to the input directory.
        *   `get_faiss_path(doc_type: str) -> Path`: Returns the path for a FAISS index file for a given `doc_type` (e.g., `output/faiss/my_document_type.faiss`).
        *   `get_metadata_path(doc_type: str) -> Path`: Returns the path for a metadata file for a given `doc_type` (e.g., `output/metadata/my_document_type_metadata.jsonl`).
        *   `get_log_path(module: str, run_id: str | None = None) -> Path`: Returns the path for a log file, typically under `output/logs/`, for a specific `module` and an optional `run_id`.
        *   `get_chunks_path() -> Path`: Returns the path to the `chunks.tsv` file located in the `input` directory (i.e., `<root_dir>/input/chunks.tsv`). *(Note: This seems to point to a generic chunks file; specific per-doc_type chunk files like `chunks_<doc_type>.tsv` are also used and typically reside in `input_dir` as well).*

### Static Methods

In addition to its instance methods, the `ProjectManager` class also provides several static methods for project creation and configuration management:

- **`create_project(...)`**: A utility to bootstrap a new project. It creates the necessary directory structure and generates a default `config.yml` file with a standard configuration.
- **`get_config_schema()`**: Returns a dictionary representing the expected structure and data types of the `config.yml` file. This is useful for validation and for understanding the available configuration options.
- **`validate_config(config_data)`**: Takes a dictionary of configuration data and validates it against the schema. It returns a tuple containing a boolean indicating whether the configuration is valid and a list of any validation errors.
- **`validate_config_file(config_path)`**: A convenience method that reads a `config.yml` file from a given path, loads its content, and then uses `validate_config` to check its validity.

### Integration with Other Modules:

The `ProjectManager` is a foundational class used throughout the project to provide context and access to resources. Key integrations include:

-   **Application CLI (`app/cli.py`)**:
    *   Each CLI command (e.g., `ingest`, `embed`, `retrieve`) typically starts by instantiating `ProjectManager` for the specified project directory.
    *   It uses `ProjectManager` to access project configuration (`project.config`) and to obtain paths for logging (`project.get_log_path()`).
    *   The `project` instance is passed to other managers like `IngestionManager`, `UnifiedEmbedder`, and `RetrievalManager`.

-   **Embedding Subsystem (`scripts/embeddings/`)**:
    *   `scripts/embeddings/embedder_registry.py`: The `get_embedder` function receives a `ProjectManager` instance to access `project.config` for determining the embedding provider and its settings.
    *   `scripts/embeddings/unified_embedder.py`: The `UnifiedEmbedder` is initialized with `ProjectManager`. It uses it for:
        *   Accessing configuration related to embedding (batch size, async mode).
        *   Getting paths for logs, input chunk files (`project.get_chunks_path()`, `project.input_dir`), and output FAISS/metadata files (`project.get_faiss_path()`, `project.get_metadata_path()`).

-   **Retrieval Subsystem (`scripts/retrieval/`)**:
    *   `scripts/retrieval/retrieval_manager.py`: The `RetrievalManager` is initialized with `ProjectManager`. It uses it for:
        *   Discovering available document types by scanning `project.faiss_dir`.
        *   Obtaining paths to FAISS index files and metadata files for each document type.
        *   Accessing the project configuration to initialize the appropriate query embedder via the `embedder_registry`.

In essence, `ProjectManager` ensures that all parts of the RAG application operate within a well-defined and consistent project environment. It decouples specific path and configuration logic from the core processing modules, making the system more modular and easier to manage.
